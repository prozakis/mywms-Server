/*
 * Copyright (c) 2006 - 2010 LinogistiX GmbH
 * 
 *  www.linogistix.com
 *  
 *  Project myWMS-LOS
 */
package de.linogistix.inventory.report.queryinventory.gui.gui_builder;

import de.linogistix.common.bobrowser.bo.editor.PlainObjectReadOnlyEditor;
import de.linogistix.common.services.J2EEServiceLocator;
import de.linogistix.common.util.ExceptionAnnotator;
import de.linogistix.los.inventory.businessservice.QueryInventoryTO;
import de.linogistix.los.inventory.facade.QueryInventoryFacade;
import de.linogistix.reports.res.ReportsBundleResolver;
import java.awt.BorderLayout;
import java.beans.PropertyEditor;
import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JComponent;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.ExplorerUtils;
import org.openide.explorer.view.TreeTableView;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.openide.nodes.Node.Property;
import org.openide.nodes.Node.PropertySet;
import org.openide.nodes.PropertySupport;
import org.openide.nodes.Sheet;
import org.openide.util.Lookup;
import org.openide.util.NbBundle;

/**
 *
 * @author  artur
 */
public class AbstractTreeTableViewPanel extends javax.swing.JPanel implements ExplorerManager.Provider{

    private Logger log = Logger.getLogger(AbstractTreeTableViewPanel.class.getName());
    
    public TreeTableView v;
    protected ExplorerManager manager = new ExplorerManager();
    final static private String CLIENTREF = NbBundle.getMessage(ReportsBundleResolver.class, "clientRef");
    final static private String ARTICLEREF = NbBundle.getMessage(ReportsBundleResolver.class, "articleRef");
    final static private String LOTREF = NbBundle.getMessage(ReportsBundleResolver.class, "lotRef");

    final static private String CURRENTINSTOCK = NbBundle.getMessage(ReportsBundleResolver.class, "currentInStock");
    final static private String CURRENTRESERVED = NbBundle.getMessage(ReportsBundleResolver.class, "currentReserved");
    final static private String CURRENTADVISED = NbBundle.getMessage(ReportsBundleResolver.class, "currentAdvised");
    final static private String CURRENTAVAILABLE = NbBundle.getMessage(ReportsBundleResolver.class, "currentAvailable");
    final static private String CURRENTLOCKED = NbBundle.getMessage(ReportsBundleResolver.class, "currentlocked");

    /** Creates new form AbstractTreeTableViewPanel */
    public AbstractTreeTableViewPanel() {
        initComponents();
        postInit();
    }
    
    

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.BorderLayout());
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    private void postInit() {
        v = new TreeTableView();
        //JScrollPane p = v;
//        JScrollPane scroll = new JScrollPane();
//        scroll.getViewport().add(v);
        add(v, BorderLayout.CENTER);
        //Make shure that the table-header will be shown.
        setNodes(null, null, null, false);
    }

    
    public ExplorerManager getExplorerManager() {
        return manager;
    }

    public static class InventoryNode extends AbstractNode {

        Sheet.Set sheet = null;
        QueryInventoryTO to;
        
        public InventoryNode(QueryInventoryTO to) {
            super(Children.LEAF);
            this.to = to;
        }

        @Override
        public Action[] getActions(boolean arg0) {
            return super.getActions(arg0);
        }
        
        public List<QueryInventoryTO.LockAmountEntry >getLockAmountEntries(){
            return to.lockList;
        }
        
        @Override
        @SuppressWarnings("unchecked")
        public PropertySet[] getPropertySets() {
            if (sheet == null) {
                sheet = new Sheet.Set();
                sheet.setName("inv props");
                sheet.setPreferred(true);
                
                InventoryProperty<String> clientRef = new InventoryProperty("clientRef", String.class, CLIENTREF, to.clientRef);
                InventoryProperty<String> articleRef = new InventoryProperty("articleRef", String.class, ARTICLEREF, to.articleRef);
                InventoryProperty<String> lotRef = new InventoryProperty("lotRef", String.class,LOTREF , to.lotRef);
                InventoryProperty<Integer> currentInStock = new InventoryProperty("currentInStock", String.class, CURRENTINSTOCK, to.inStock);
                InventoryProperty<Date> currentReserved = new InventoryProperty("currentReserved", Date.class, CURRENTRESERVED, to.reserved);
                InventoryProperty<Integer> currentAdvised = new InventoryProperty("currentAdvised", String.class, CURRENTADVISED, to.advised);
                InventoryProperty<Integer> currentAvailable = new InventoryProperty("currentAvailable", String.class, CURRENTAVAILABLE, to.available);
                InventoryProperty<Integer> currentlocked = new InventoryProperty("currentlocked", String.class, CURRENTLOCKED, to.locked);

                sheet.put(clientRef);
                sheet.put(articleRef);
                sheet.put(lotRef);
                sheet.put(currentInStock);
                sheet.put(currentReserved);
                sheet.put(currentAdvised);
                sheet.put(currentAvailable);
                sheet.put(currentlocked);
                
                for (QueryInventoryTO.LockAmountEntry e : to.lockList){
                    InventoryProperty<BigDecimal> lockE = new InventoryProperty("" + e.lock, BigDecimal.class, "" + e.lock, e.amount);
                     sheet.put(lockE);
                }

            }
            return new PropertySet[]{sheet};
        }

        @SuppressWarnings("unchecked")
        public static Property[] templateProperties() {

            InventoryProperty<String> clientRef = new InventoryProperty("clientRef", String.class, CLIENTREF,null);
            InventoryProperty<String> articleRef = new InventoryProperty("articleRef", String.class, ARTICLEREF,null);
            InventoryProperty<String> lotRef = new InventoryProperty("lotRef", String.class,LOTREF , null);

            InventoryProperty<Integer> currentInStock = new InventoryProperty("currentInStock", String.class, CURRENTINSTOCK,null);
            InventoryProperty<Date> currentReserved = new InventoryProperty("currentReserved", Date.class, CURRENTRESERVED,null);
            InventoryProperty<Integer> currentAdvised = new InventoryProperty("currentAdvised", String.class, CURRENTADVISED,null);
            InventoryProperty<Integer> currentAvailable = new InventoryProperty("currentAvailable", String.class, CURRENTAVAILABLE,null);
            InventoryProperty<Integer> currentlocked = new InventoryProperty("currentlocked", String.class, CURRENTLOCKED,null);

            Property[] properties = new Property[]{
                clientRef,
                articleRef,
                lotRef,
                currentInStock,
                currentReserved,
                currentAdvised,
                currentAvailable,
                currentlocked
            };
            return properties;
        }

        @Override
        public boolean equals(Object obj) {
            InventoryNode n;
            if (obj != null) {
                return false;
            }
            if (obj instanceof InventoryNode) {
                n = (InventoryNode) obj;
                return (to.equals(n.to));
            } else {
                return false;
            }
        }
        
        
    }
    
    protected static class InventoryProperty<T> extends PropertySupport.ReadWrite<T> {

        T value;

        @Override
        public PropertyEditor getPropertyEditor() {
            return new PlainObjectReadOnlyEditor();
        }

        InventoryProperty(String name, Class<T> type, String displayName, T value) {
            super(name, type, displayName, "");
            this.value = value;
            setValue("ComparableColumnTTV", Boolean.TRUE);
        }

        public T getValue() throws IllegalAccessException, InvocationTargetException {
            return value;
        }

        @Override
        public void setValue(T arg0) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
            // do nothing
        }
    }

    protected static enum GetMode {
        INVENTORY_LIST_CONSOLIDATE_LOT,
        INVENTORY_LIST,
        INVENTORY_BY_ARTICLE,
        INVENTORY_BY_BATCH,
        INVENTORY_BY_ARTICLE_CONSOLIDATE_LOT;
    }

    @SuppressWarnings("unchecked")
    public void setNodes(final String client, final String articel, final String printNorm, final boolean groupedByArticle) {
        Children.Keys<Object> keys = new Children.Keys<Object>() {

            @Override
            protected Node[] createNodes(Object arg0) {
                if (arg0 instanceof QueryInventoryTO) {
                    return new Node[]{new InventoryNode((QueryInventoryTO) arg0)};
                } else {
                    return new Node[0];
                }

            }

            @Override
            protected void addNotify() {

                QueryInventoryTO[] tos = null;
                QueryInventoryTO to = null;
                GetMode mode = GetMode.INVENTORY_LIST;
                
                if ( groupedByArticle){
                    if (printNorm != null && printNorm.length() != 0) {
                        mode = GetMode.INVENTORY_BY_BATCH;
                    } else if (articel != null && articel.length() != 0) {  
                        mode = GetMode.INVENTORY_BY_ARTICLE_CONSOLIDATE_LOT;    
                    } else {
                        mode = GetMode.INVENTORY_LIST_CONSOLIDATE_LOT;
                    }
                } else{
                    if (printNorm != null && printNorm.length() != 0) {
                        mode = GetMode.INVENTORY_BY_BATCH;
                    } else if (articel != null && articel.length() != 0) {
                        mode = GetMode.INVENTORY_BY_ARTICLE;
                    } else {
                        mode = GetMode.INVENTORY_LIST;
                    }
                }
                
                if (client != null) {
                    try {
                        J2EEServiceLocator loc = (J2EEServiceLocator) Lookup.getDefault().lookup(J2EEServiceLocator.class);
                        QueryInventoryFacade r = (QueryInventoryFacade) loc.getStateless(QueryInventoryFacade.class);
                       
                        String ref;
                        String user = "";
                        String passwd = "";
                        switch (mode) {
                           
                            case INVENTORY_LIST_CONSOLIDATE_LOT:
                                tos = r.getInventoryList(client, true);
                                break;
                            case INVENTORY_LIST:
                                tos = r.getInventoryList(client, false);
                                break;
                            case INVENTORY_BY_ARTICLE:
                                ref = articel;
                                tos = r.getInventoryByArticle(client, ref, false);
                                break;
                            case INVENTORY_BY_BATCH:          
                                to = r.getInventoryByLot(client, articel, printNorm);
                                break;  
                            case INVENTORY_BY_ARTICLE_CONSOLIDATE_LOT:
                                ref = articel;
                                tos = r.getInventoryByArticle(client, ref, true);
                                break; 
                            default:
                                throw new IllegalStateException();
                        }

                        //if clearing is selected
                        if (tos != null) {
                            setKeys(tos);
                        } else {
                            setKeys(new QueryInventoryTO[]{to});
                        }
                    } catch (Throwable ex) {
                        ExceptionAnnotator.annotate(ex);
                    }
                }
            }
            };
        Node root = new AbstractNode(keys);
        v.setProperties(InventoryNode.templateProperties());
        v.setRootVisible(false);
        manager.setRootContext(root);
//            mgr.setSelectedNodes(new Node[]{root.getChildren().getNodes()[0]});
    }

}
